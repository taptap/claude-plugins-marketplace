# 代码审查维度详解

本文档定义 quality plugin 的四大审查维度，为所有 Agent 提供统一的审查标准。

## 1. Bug 检测（Bug Detection）

### 定义

识别代码中会导致程序错误、崩溃或不符合预期行为的问题。

### 检查类别

#### 1.1 逻辑错误
- **条件判断错误**：if 条件写反、逻辑运算符错误（&& vs ||）
- **循环逻辑问题**：死循环、循环边界错误、提前 break
- **状态管理错误**：状态转换错误、状态不一致
- **边界条件**：off-by-one、未处理空集合、未处理极端值

#### 1.2 Nil/Null 指针
- **未检查 nil**：解引用前未检查 nil
- **返回 nil**：函数返回 nil 但调用方未检查
- **集合未初始化**：Slice/Map/数组未初始化就使用

#### 1.3 数组越界
- **索引越界**：访问超出数组长度的索引
- **Slice 切片越界**：切片操作超出范围
- **未检查长度**：使用前未检查集合长度

#### 1.4 资源泄漏
- **文件/连接未关闭**：打开文件、数据库连接后未关闭
- **Goroutine 泄漏**：启动 Goroutine 但没有退出机制
- **内存泄漏**：持续分配内存但不释放
- **锁未释放**：加锁后未解锁

#### 1.5 并发安全
- **数据竞争**：多个 Goroutine 同时读写同一变量
- **死锁风险**：锁的获取顺序不一致
- **Goroutine 不安全操作**：非线程安全对象的并发访问

#### 1.6 错误处理
- **忽略错误**：`err` 返回值被忽略
- **错误处理不完整**：只处理部分错误情况
- **Panic 未 recover**：可能 panic 的代码未 recover

### 严重性级别

- **High**: 必然导致崩溃或数据错误
- **Medium**: 在特定条件下导致错误
- **Low**: 潜在问题，可能在极端情况下出现

### 示例

**High Severity - Nil 指针解引用**
```go
// ❌ Bug
func ProcessData(data *Data) {
    data.Process()  // 如果 data 为 nil，会 panic
}

// ✅ Fixed
func ProcessData(data *Data) {
    if data != nil {
        data.Process()
    }
}
```

---

## 2. 代码质量（Code Quality）

### 定义

评估代码的可读性、可维护性和对最佳实践的遵循程度。

### 检查类别

#### 2.1 可读性
- **命名清晰度**：变量/函数名是否表意清晰
- **注释完整性**：复杂逻辑是否有注释
- **代码组织**：逻辑分组、模块划分
- **Magic Number/String**：硬编码的数字/字符串应定义为常量

#### 2.2 命名规范
- **命名风格**：驼峰命名 vs 下划线命名
- **缩写使用**：缩写是否合理（ID vs Id）
- **常量命名**：全大写 + 下划线
- **包/模块命名**：简洁、小写、无下划线

#### 2.3 代码结构
- **函数长度**：建议 < 50 行，超过需要拆分
- **嵌套层级**：建议 < 4 层，过深难以理解
- **职责单一**：一个函数只做一件事
- **重复代码**：DRY 原则，提取公共逻辑

#### 2.4 复杂度
- **圈复杂度**：if/switch/loop 过多
- **认知复杂度**：代码理解难度
- **过多的 if-else**：考虑使用多态或策略模式
- **深层嵌套**：难以阅读和维护

#### 2.5 最佳实践
- **语言惯用法**：使用语言的标准写法
- **设计模式**：合理使用设计模式
- **SOLID 原则**：单一职责、开闭原则等
- **DRY 原则**：避免重复代码

### 严重性级别

- **High**: 严重影响可维护性（如 200 行函数）
- **Medium**: 明显的质量问题（如过多重复代码）
- **Low**: 轻微改进建议（如命名可以更清晰）

### 示例

**Medium Severity - 函数过长**
```go
// ❌ 函数太长（78 行）
func ProcessMessage(msg *Message) error {
    // ... 78 lines of code ...
}

// ✅ 拆分为多个子函数
func ProcessMessage(msg *Message) error {
    if err := parseMessage(msg); err != nil {
        return err
    }
    if err := validateMessage(msg); err != nil {
        return err
    }
    return saveMessage(msg)
}
```

---

## 3. 安全检查（Security）

### 定义

识别可能导致安全漏洞的代码模式和潜在安全风险。

### 检查类别

#### 3.1 注入攻击
- **SQL 注入**：直接拼接用户输入到 SQL
- **命令注入**：直接执行包含用户输入的命令
- **LDAP/XPath/XML 注入**：类似 SQL 注入

#### 3.2 XSS/CSRF
- **跨站脚本（XSS）**：未转义的用户输入输出到 HTML
- **跨站请求伪造（CSRF）**：缺少 CSRF Token
- **DOM XSS**：客户端脚本处理用户输入不当

#### 3.3 敏感信息泄漏
- **密码/密钥硬编码**：代码中直接写密码
- **敏感日志**：密码、Token 记录到日志
- **未加密传输**：敏感数据明文传输
- **API 密钥暴露**：前端代码包含 API 密钥

#### 3.4 不安全的加密
- **弱加密算法**：MD5、SHA1 用于安全场景
- **硬编码密钥**：加密密钥写在代码中
- **不安全的随机数**：使用 `math/rand` 生成安全相关随机数
- **CBC 模式未使用 IV**：AES-CBC 未使用初始化向量

#### 3.5 认证/授权
- **绕过认证**：缺少认证检查
- **权限检查缺失**：未验证用户权限
- **Session 管理**：Session 固定、Session 劫持
- **Token 泄漏**：JWT Token 暴露或泄漏

#### 3.6 其他安全问题
- **路径遍历**：文件路径未验证
- **XML 外部实体（XXE）**：XML 解析未禁用外部实体
- **反序列化漏洞**：不可信数据反序列化
- **SSRF**：服务端请求伪造

### 严重性级别

- **High**: 可直接导致数据泄漏、系统入侵
- **Medium**: 需要一定条件才能利用
- **Low**: 安全配置不佳、信息泄漏

### 示例

**High Severity - SQL 注入**
```go
// ❌ SQL 注入漏洞
query := fmt.Sprintf("SELECT * FROM users WHERE id = %s", userId)
db.Query(query)

// ✅ 使用参数化查询
db.Query("SELECT * FROM users WHERE id = ?", userId)
```

---

## 4. 性能问题（Performance）

### 定义

识别影响程序性能的代码模式和优化机会。

### 检查类别

#### 4.1 数据库性能
- **N+1 查询**：循环中执行查询
- **缺少索引**：全表扫描
- **大量小查询**：应该用批量查询
- **未使用连接池**：频繁创建连接

#### 4.2 算法复杂度
- **时间复杂度高**：O(n²) 可优化为 O(n)
- **空间复杂度高**：不必要的内存占用
- **嵌套循环**：多重循环导致复杂度高
- **不必要的排序**：重复排序或不需要排序

#### 4.3 内存管理
- **内存分配过多**：频繁的小对象分配
- **大对象创建**：不必要的大对象
- **不必要的拷贝**：可以传指针时传值
- **内存泄漏**：持续增长的内存占用

#### 4.4 并发性能
- **锁竞争**：多个 Goroutine 竞争同一个锁
- **过度锁定**：锁的范围过大
- **Goroutine 滥用**：创建过多 Goroutine
- **Channel 阻塞**：无缓冲 Channel 导致阻塞

#### 4.5 I/O 性能
- **同步 I/O 阻塞**：应该用异步 I/O
- **频繁的小 I/O**：应该批量读写
- **未使用缓冲**：应该用 bufio
- **文件重复打开**：应该重用文件句柄

#### 4.6 其他性能问题
- **字符串频繁拼接**：应该用 strings.Builder
- **正则重复编译**：应该预编译
- **反射滥用**：过度使用反射影响性能
- **类型转换**：不必要的类型转换

### 严重性级别

- **High**: 严重影响性能（如 O(n²) 算法）
- **Medium**: 明显性能问题（如 N+1 查询）
- **Low**: 轻微性能优化（如字符串拼接）

### 示例

**High Severity - N+1 查询**
```go
// ❌ N+1 查询问题
for _, userId := range userIds {
    user, _ := db.Query("SELECT * FROM users WHERE id = ?", userId)
    // process user
}

// ✅ 批量查询
users, _ := db.Query("SELECT * FROM users WHERE id IN (?)", userIds)
```

---

## 跨维度考虑

某些问题可能跨越多个维度：

| 问题 | Bug | 质量 | 安全 | 性能 |
|------|-----|------|------|------|
| 未检查错误返回值 | ✓ | ✓ | | |
| SQL 注入 | | | ✓ | |
| N+1 查询 | | | | ✓ |
| Goroutine 泄漏 | ✓ | | | ✓ |
| 硬编码密码 | | ✓ | ✓ | |
| 深层嵌套 | | ✓ | | |

当问题跨越多个维度时，优先归类为最严重的维度（安全 > Bug > 性能 > 质量）。

---

## 审查优先级

1. **安全问题**：优先级最高，零容忍
2. **Bug**：必须修复，影响功能正确性
3. **性能问题**：根据影响评估优先级
4. **代码质量**：优先级较低，可后续改进

---

## 参考资料

- OWASP Top 10: https://owasp.org/www-project-top-ten/
- Go Code Review Comments: https://go.dev/wiki/CodeReviewComments
- Effective Go: https://go.dev/doc/effective_go
